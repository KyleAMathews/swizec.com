export const title = "Module 3"

export const description = ""

export const image = "/chapter_headers/serverless-elements.png"
import { Vimeo } from "../components/Video"

# Building static pages dynamically

Here we use GraphQL at compile time to create all those user landing pages as actual Gatsby pages in our app.

## Add an allPages query on the server

<Vimeo id="393475422" />

## Dynamically create static Gatsby pages

<Vimeo id="393476022" />

## Render created pages

<Vimeo id="393695621" />

## Fetch fresh data on page load

<Vimeo id="394232762" />

## Add page query to server

<Vimeo id="394233203" />

## Show content and editor side-by-side

<Vimeo id="394233582" />

## Render markdown with Remark

<Vimeo id="394702938" />

We're using [remark](https://github.com/remarkjs/remark) to render our editable Markdown content. It's the same rendering engine that Gatsby uses when you want to use markdown pages with gatsby-plugin-remark. That approach is meant for static content uneditable by users hoewver.

You can read about the details behind this code in [my article about building remark plugins](https://swizec.com/blog/buildremark-plugin-supercharge-static-site/swizec/8860) and my [article on custom markdown extensions](https://swizec.com/blog/custom-markdown-extensions-with-remark-and-hast-handlers/swizec/9018)

I used those to build [TechLetter.App](https://techletter.app). We use a simplified `useRemark` hook for our project.

```javascript
import { useState, useEffect } from "react"
import remark from "remark"
import remark2react from "remark-react"

export const remarkCompile = input =>
  new Promise((resolve, reject) => {
    remark()
      .use(remark2react, {
        sanitize: false,
      })
      .process(input, (err, output) => {
        if (err) {
          reject(err)
        } else {
          resolve(output)
        }
      })
  })

export default function useRemark(input) {
  const [rendered, setRendered] = useState("")

  useEffect(() => {
    remarkCompile(input)
      .then(output => setRendered(output.contents))
      .catch(err => console.error(err))
  }, [input])

  return rendered
}
```

## Live edit page

<Vimeo id="394703083" />

## Editing requires auth

<Vimeo id="394703224" />

## Add save button

<Vimeo id="394976748" />

## savePage mutation

<Vimeo id="394977281" />

## debug odd savePage issue

This is a little painful to watch and the mistake was very dumb in the end - not mapping the `savePage` resolver to the `savePage` mutation. ü§¶‚Äç‚ôÇÔ∏è

Video included because it's a good example of step by step debugging that you'll need when debugging your own project :)

<Vimeo id="394977952" />
